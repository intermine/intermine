<?xml version="1.0"?>

<article>

  <artheader>
    <date>2003-03-12</date>
    <title>Running Explain for Flymine Queries</title>
    <authorgroup>
      <author>
        <firstname>Richard</firstname>
        <surname>Smith</surname>
      </author>
      <author>
        <firstname>Matthew</firstname>
        <surname>Wakeling</surname>
      </author>
    </authorgroup>
  </artheader>

  <sect1>
    <title>Overview</title>
    <para>This document summarises our discussion about the role of EXPLAIN in running FlyMine queries and how it should be implemented. The purpose of running EXPLAIN is to obtain estimated information about the time to run a query and the number of rows it will return allowing us to limit what is run in the database.  We also want to make estimated (and/or computed) statistics about a query available to client applications prior to execution.</para>
    
  </sect1>
  
  <sect1>
    <title>Information available from EXPLAIN</title>
    <para>EXPLAIN displays the execution plan that the planner produces for a given SQL statement.  The plan details how tables will be scanned and what join strategies will be used.  In addition some estimated statistics are produced for the query:</para>
    <itemizedlist>
      <listitem>The estimated cost of running a query in terms of disk page fetches, two figures are displayed:
        <itemizedlist>
          <listitem>estimated time for the first row to be returned</listitem>
          <listitem>estimated time for completion of entire query</listitem>
        </itemizedlist>
      </listitem>
      <listitem>An estimated number of rows that the query will return, based on estimated selectivity of where clauses.</listitem>
      <listitem>The average width (bytes) of rows produced by the query</listitem>
    </itemizedlist>
  </sect1>
  

  <sect1>
    <title>When we need to run EXPLAIN</title>
    <para>Our purpose in running EXPLAIN for all queries is twofold:</para>
    <itemizedlist>
      <listitem>to provide users with an estimated number of rows a given query will produce.</listitem>
      <listitem>to prevent queries that would take more than a threshold amount of time from being run in the database.</listitem>
    </itemizedlist>
    <para>Our implementation of paging dictates that these are two distinct operations.  When a query is run the <classname>Results</classname> object defines a LIMIT and OFFSET to restrict the number of rows returned at one time (e.g the first 1000).  It is when when this limited query is run that we need to restrict the amount of time it can take.  To estimate the total number of rows a query will return we obviously need to EXPLAIN it without a LIMIT.      
    </para>
    <para>Thus, we need to run EXPLAIN on the original query and on each 'page' with OFFSET and LIMIT defined. This is done as follows:
      <itemizedlist>
        <listitem><function>ObjectStore.estimate(query)</function> method that, given a query, will return an estimated number of rows.
            This is called as required by the client application and is not necessary for normal query execution.
            In future this could be modified to provide an actual computed number of rows.
            An EXPLAIN could check whether COUNT(*) for the query would be fast to run, if so run it and return the actual number of rows.</listitem>
        <listitem><function>ObjectStoreFlyMineImpl.execute(query, start, limit)</function> calls <function>Objectstore.explain(query, start, limit)</function> and decides if the query is faster or slower that the given threshold.
            If the query is too slow an Exception is thrown, otherwise the query runs as normal.
            The threshold is provided in the properties file, so that users could set their own maximum execution time (such that it is less than our global threshold).</listitem>
        </itemizedlist>
</para>

  </sect1>

  <sect1>
    <title>Caching SQL statements</title>
    <para>Our system of paging means that queries will often be run multiple times with different LIMIT and OFFSET parameters.
        It might be thought therefore that it would be beneficial to implement a cache of generated SQL text.
        However, the Query.equals() and Query.hashCode() methods are relatively heavy methods, so looking up an entry in such a cache would take as much time as generating the SQL in the first place.</para>
  </sect1>
</article>
