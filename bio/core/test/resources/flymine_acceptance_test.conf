# acceptance tests for FlyMine

assert {
  sql: select count(*) = 15 from organism
}

no-results {
  sql: select * from organism where genus is null or species is null or abbreviation is null or shortname is null or name is null or taxonid is null
  note: all fields of all organisms should be filled in
}

no-results {
  sql: select * from datasource where url is null or name is null or description is null;
  note: all fields of data source should be filled in
}

some-results {
  sql: select * from sequencevariant where id in (select genes from genessequencevariant);
  note: at least some SequenceVariant objects should have gene references
}
some-results {
  sql: select cds.id, identifier, length(intermine_sequence.residues), intermine_end - intermine_start + 1 as calc_length from cds, location, intermine_sequence where chromosomelocationid = location.id and length(intermine_sequence.residues) <> intermine_end - intermine_start + 1 limit 10
  note: make sure that there are at least some CDSs with lengths shorter than the end-start+1, which is evidence that the CDS lengths are the (sum of the exon lengths - UTR length) see #621
}
some-results {
  sql: select * from organism where name = 'Anopheles gambiae str. PEST'
  note: We should have an Anopheles gambiae PEST object but not an Anopheles gambiae one
}

no-results {
  sql: select * from intermineobject where id in (select b.id from bioentity b where organismid is null and not exists (select p.id from proteinfeature p where b.id = p.id) and not exists (select pr.id from proteinregion pr where b.id = pr.id))
  note: all BioEntity objects should have an organism (exception if ProteinFeature or ProteinRegion)
}
no-results {
  sql: select * from intermineobject where id in (select b.id from bioentity b where organismid is null and not exists (select p.id from proteinfeature p where b.id = p.id) and not exists (select pr.id from proteinregion pr where b.id = pr.id)) limit 1000
  note: all BioEntity objects should have an organism (exception if ProteinFeature or ProteinRegion)
}
no-results {
  sql: select gene.id from gene where length > 1000000
  note: no genes should be too long
}
no-results {
  sql: select l1.id, l1.intermine_start, l2.id, l2.intermine_end from location as l1, location as l2 where l1.subjectid = l2.subjectid and l1.objectid = l2.objectid and l1.intermine_start = l2.intermine_start and l1.intermine_end = l2.intermine_end and l1.id <> l2.id
  note: no two location objects should have the same objectid, subjectid, start and end positions
}
no-results {
  sql: select rr1.identifier, rr1.id, rr2.identifier, rr2.id from regulatoryregion as rr1, regulatoryregion as rr2 where rr1.identifier = rr2.identifier and rr1.id <> rr2.id
  note: no two regulatoryregions should have the same identifier (see #564)
}
no-results {
  sql: select gene1.identifier, gene1.id, gene2.identifier, gene2.id from gene as gene1, gene as gene2 where gene1.identifier = gene2.identifier and gene1.id <> gene2.id
  note: no two genes should have the same identifier
}
no-results {
  sql: select translation1.identifier, translation1.id, translation2.identifier, translation2.id from intermine_translation as translation1, intermine_translation as translation2 where translation1.identifier = translation2.identifier and translation1.id <> translation2.id
  note: no two Translation objects should have the same identifier
}
no-results {
  sql: select transcript1.identifier, transcript1.id, transcript2.identifier, transcript2.id from transcript as transcript1, transcript as transcript2 where transcript1.identifier = transcript2.identifier and transcript1.id <> transcript2.id
  note: no two Transcript objects should have the same identifier
}
no-results {
  sql: select loc1.id, loc2.id, sv.id from location as loc1, location as loc2, sequencevariant as sv where loc1.subjectid = loc2.subjectid and loc1.subjectid = sv.id and loc1.id <> loc2.id
  note: no sequencevariants should have more than one location (ticket #540)
}
no-results {
  sql: select * from chromosomeband where identifier = '-'
  note: see #567
}
no-results {
  sql: select * from regulatoryregion where chromosomelocationid is null
  note: see #569
}
no-results {
  sql: select lsf.id, lsf.identifier, intermine_sequence.id from locatedsequencefeature as lsf, intermine_sequence where intermine_sequence.id = sequenceid and length(intermine_sequence.residues) <> lsf.length
  note: LocatedSequenceFeature.length should equal the length of the Sequence.residues (see #669)
}
no-results {
  sql: select lsf.id, lsf.identifier, lsf.length, seq.id, seq.length from locatedsequencefeature as lsf, intermine_sequence as seq where lsf.sequenceid = seq.id and lsf.length != seq.length
  note: LocatedSequenceFeature.length should equal the length of the Sequence.length (see #669)
}
no-results {
  sql: select id, length from intermine_sequence where length <= 0;
  note: Sequence.length should be greater than 0
}
no-results {
  sql: select subjectid, sourceid, type, intermine_value, count(*) from synonym group by subjectid, sourceid, type, intermine_value having count(*) > 1
  note: If synonym key used correctly for all sources there should be no duplicate synonyms
}
no-results {
  sql: select * from intermineobject where id in (select b.id from bioentity b where b.identifier is not null and not exists (select * from synonym s where s.intermine_value = b.identifier and s.subjectid = b.id)) limit 100
  note: all BioEntities should have their identifier as a synonm
}
no-results {
  sql: select * from intermineobject where id in (select g.id from gene g where g.organismDbId is not null and not exists (select * from synonym s where s.intermine_value = g.organismDbId and s.subjectid = g.id)) limit 100
  note: all Genes should have their organismDbId as a synonm
}
no-results {
  sql: select * from intermineobject where id in (select g.id from gene g where g.symbol is not null and not exists (select * from synonym s where s.intermine_value = g.symbol and s.subjectid = g.id)) limit 100
  note: all Genes should have their symbol as a synonm
}
no-results {
  sql: select * from intermineobject where id in (select p.id from protein p where p.primaryAccession is not null and not exists (select * from synonym s where s.intermine_value = p.primaryAccession and s.subjectid = p.id)) limit 100
  note: all Proteins should have their primaryAccession as a synonm
}
no-results {
  sql: select t1.id, t1.identifier, t2.id, t2.identifier from intermine_translation as t1, intermine_translation as t2 where t1.id != t2.id and t1.identifier = t2.identifier
  note: no two Translations should have the same identifier
}
no-results {
  sql: select * from intermine_translation where transcriptid is null;
  note: all Translations should have a non-null transcriptid
}
no-results {
  sql: select * from mrna where translationid is null;
  note: all MRNAs should have a non-null translationid
}
no-results {
  sql: select distinct a1_.id, a1_.identifier, a1_.name, a2_.id, a2_.identifier from gene as a1_, intergenicregion as a2_, locatedsequencefeatureoverlappingfeatures as indirect0 where a1_.id = indirect0.overlappingfeatures and indirect0.locatedsequencefeature = a2_.id
  note: No genes should overlap IntergenicRegions
}
no-results {
  sql: select * from organism where name = 'Anopheles gambiae'
  note: We should have an Anopheles gambiae PEST object but not an Anopheles gambiae one
}

results-report {
  sql: select * from datasource
  max-results: 1000
}
results-report {
  sql: select * from organism
}
