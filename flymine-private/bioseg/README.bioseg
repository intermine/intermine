This directory contains the code for the user-defined type,
BIOSEG, representing contiguous intervals in biological sequence.

(Most of this documentation is copied from contrib/seg/README.seg in the
PostgreSQL source).


FILES
=====

Makefile                building instructions for the shared library

README.bioseg           the file you are now reading

bioseg.c                the implementation of this data type in C

bioseg.sql.in           SQL code needed to register this type with PostgreSQL
                        (transformed to bioseg.sql by make)

INSTALLATION
============

Change into the contrib directory in PostgreSQL and unpack the bioseg tar
file:
    gzip -d < bioseg-x.y.tar.gz | tar xf -

To install the type, change to the bioseg directory and run

    make
    make install

The user running "make install" may need root access; depending on the
configuration of PostgreSQL.

This only installs the type implementation and documentation.  To make the
type available in any particular database, do

    psql -d databasename < bioseg.sql

If you install the type in the template1 database, all subsequently created
databases will inherit it.

To test the new type, after "make install" do

    make installcheck

If it fails, examine the file regression.diffs to find out the reason (the
test code is a direct adaptation of the regression tests from the main
source tree).

If you have a full installation of PostgreSQL, including the pg_config
program, bioseg can be unpacked anywhere and built like:

     make USE_PGXS=t
     make install USE_PGXS=t

and the type can then be installed in a particular database by any user with:

    psql -d databasename < `pg_config --sharedir`/contrib/bioseg.sql


SYNTAX
======

The external representation of an interval is formed using one or two
integers greater than 0 joined by the range operator ('..' or '...'). 
The first integer must be less than or equal to the second.

11..22        An interval from 10 to 20 inclusive - length 11 (= 22-11+1)

1...2         The same as 1..2

50            The same as 50..50


USAGE
=====

Available operators include:

[a, b] && [c, d]        Overlaps

        Returns true if and only if segments [a, b] and [c, d] overlap

[a, b] << [c, d]        Is left of

        The left operand, [a, b], occurs entirely to the left of the
        right operand, [c, d].  It means, [a, b] << [c, d] is true if b
        < c and false otherwise

[a, b] >> [c, d]        Is right of

        [a, b] is occurs entirely to the right of [c, d]. 
        [a, b] >> [c, d] is true if a > d and false otherwise

[a, b] &< [c, d]        Overlaps or is left of

        This might be better read as "does not extend to right of".
        It is true when b <= d.

[a, b] &> [c, d]        Overlaps or is right of

        This might be better read as "does not extend to left of".
        It is true when a >= c.

[a, b] = [c, d]         Same as

        The segments [a, b] and [c, d] are identical, that is, a == b
        and c == d

[a, b] @> [c, d]        Contains

        The segment [a, b] contains the segment [c, d], that is, 
        a <= c and b >= d

[a, b] <@ [c, d]        Contained in

        The segment [a, b] is contained in [c, d], that is, 
        a >= c and b <= d

Although the mnemonics of the following operators is questionable, I
preserved them to maintain visual consistency with other geometric
data types defined in PostgreSQL.

Other operators:

[a, b] < [c, d]         Less than
[a, b] > [c, d]         Greater than

        These operators do not make a lot of sense for any practical
        purpose but sorting. These operators first compare (a) to (c),
        and if these are equal, compare (b) to (d). That accounts for
        reasonably good sorting in most cases, which is useful if
        you want to use ORDER BY with this type


NOTE: The performance of an R-tree index can largely depend on the
order of input values. It may be very helpful to sort the input table
on the BIOSEG column (see the script sort-segments.pl for an example)


INDEXES
=======

A GiST index can created for bioseg columns that will greatly speed up
overlaps and contains queries.  For example:

  CREATE TABLE tt (range bioseg, id integer);
  CREATE INDEX tt_range_idx ON tt USING gist (range);


INTERBASE COORDINATES
=====================

The standard bioseg type uses the common convention of numbering the bases
starting at 1.  If you wish to use "interbase" coordinates (also known as "0
based" or "half-open intervals") run the build with INTERBASE_COORDS defined
in make, ie.:

    make INTERBASE_COORDS=t
    make install INTERBASE_COORDS=t

This will compile and install the implementation for the "bioseg0" type.
The "0" in the name being a mnemonic for "0-based".

Then restart PostgreSQL and read "bioseg0.sql":
    psql -d databasename < bioseg0.sql
as to install the type in a database.

Note
----
In the interbase system '1..10'::bioseg0 and '10..20'::bioseg0 don't overlap,
whereas in the 1-based system '1..10'::bioseg and '10..20'::bioseg have a one
base overlap.  Also note that the length of '1..10'::bioseg0 is 9, whereas the
length of '1..10'::bioseg is 10.

See:
 http://www.gmod.org/wiki/index.php/Introduction_to_Chado#Interbase_Coordinates
for a longer discussion of the differences between the coordinate systems.


TESTS
=====

The installation of bioseg can be checked by running:

  make installcheck


CREDITS
=======

Note from the author: Most of the code and all of the hard work needed to
implement BIOSEG was by Gene Selkov, Jr, author of the SEG type (contrib/seg
in the PostgreSQL source).  All bugs are due to me.


AUTHOR
======

Kim Rutherford <kmr@flymine.org>
